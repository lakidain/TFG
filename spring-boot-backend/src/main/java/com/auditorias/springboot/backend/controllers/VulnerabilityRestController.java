package com.auditorias.springboot.backend.controllers;

import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import com.auditorias.springboot.backend.mapper.VulnerabilityMapper;
import com.auditorias.springboot.backend.model.Audit_Threat;
import com.auditorias.springboot.backend.model.Audit_Vulnerability;


@CrossOrigin(origins = { "http://localhost:4200" })
@RestController // Como no va a tener vista
@RequestMapping("/api") // Aqui nos generara la url
public class VulnerabilityRestController {
	
	private VulnerabilityMapper vulnerabilityMapper;

	public VulnerabilityRestController(VulnerabilityMapper vulnerabilityMapper) {
		this.vulnerabilityMapper = vulnerabilityMapper;
	}
	
	/*
	 * Returns a List with all the vulnerabilities
	 */
	@GetMapping("/vulnerabilities") //Para generar el endpoint
	public List <Audit_Vulnerability> getAllThreats() {	
		return vulnerabilityMapper.findAllVulnerabilities();
	}
	
	/*
	 * Creation of a Threat
	 */
	@PostMapping("/vulnerabilities" )
	@ResponseStatus(HttpStatus.CREATED)
	public boolean createThreat(@RequestParam("newVulnerability") String newVulnerability, @RequestParam("threatVulnerability") Long threatVulnerability, @RequestParam("existingVulnerability") Long existingVulnerability) {	//Como viene en formato JSON es necesario convertirlo	
		
		if(!("".contentEquals(newVulnerability))) {	/* Just need to create the threat if it's new*/
			vulnerabilityMapper.insertVulnerability(newVulnerability);
			existingVulnerability = vulnerabilityMapper.findVulnerability(newVulnerability).get(0).getId_audit_vulnerability();
		}
		/* If the field text is not completed we use the select, not need to create the asset, just the association */
		vulnerabilityMapper.associateThreatVulnerability(threatVulnerability, existingVulnerability);
		return true;	
	}
}
